/**
 * Properties for the DraggableWrapper component.
 * @typedef {Object} DraggableWrapperProps
 * @property {('parent'|string|{left?: number, top?: number, right?: number, bottom?: number})} [bounds] - Specifies movement boundaries for the draggable element.
 *   - `'parent'`: Restricts movement within the node's offsetParent (nearest node with position relative or absolute).
 *   - `string`: A CSS selector restricting movement within the targeted node (e.g., '#container', '.my-boundary').
 *   - `object`: An object with optional `left`, `top`, `right`, and `bottom` properties, indicating pixel offsets from the parent element's edges that the draggable element cannot cross.
 * @property {React.ReactNode} [children] - The content to be rendered inside the draggable element.
 * @property {string} [containerClassName] - Custom CSS class name(s) to apply to the outer container div of the Draggable component.
 * @property {boolean} [disabled=false] - If true, disables dragging functionality (both mouse/touch and keyboard).
 * @property {string} [handle] - A CSS selector for an element within the children that will act as the drag handle. If not specified, the entire draggable element is the handle.
 * @property {{x: number, y: number}} [initialPosition={x: 0, y: 0}] - The initial x and y coordinates for the draggable element. This is used only for the initial render. If `position` is provided, `initialPosition` is ignored.
 * @property {number} [initialPosition.x=0] - The initial horizontal position offset.
 * @property {number} [initialPosition.y=0] - The initial vertical position offset.
 * @property {boolean} [isBodyBounded=false] - If true, the draggable element is bounded by the `<body>` element, overriding the `bounds` prop.
 * @property {string} [keyboardInstructions=''] - Custom text announced by screen readers when keyboard dragging is initiated. Defaults provide basic instructions.
 * @property {(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false} [onDrag] - Callback function invoked continuously while the element is being dragged.
 * @property {(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false} [onStart] - Callback function invoked when dragging starts. Returning `false` cancels the drag operation.
 * @property {(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false} [onStop] - Callback function invoked when dragging stops.
 * @property {{x: number, y: number}} [position] - Controls the position of the draggable element externally. If provided, the component becomes controlled, and its position is solely determined by this prop. `initialPosition` is ignored.
 * @property {number} [position.x] - The controlled horizontal position offset.
 * @property {number} [position.y] - The controlled vertical position offset.
 * @property {string} [wrapperClassName] - Custom CSS class name(s) to apply to the inner wrapper div generated by `react-draggable`.
 */

/**
 * Data passed to drag event handlers.
 * @typedef {Object} DraggableData
 * @property {HTMLElement} node - The DOM node being dragged.
 * @property {number} x - The current x-coordinate relative to the offset parent.
 * @property {number} y - The current y-coordinate relative to the offset parent.
 * @property {number} deltaX - The change in x-coordinate since the last drag event.
 * @property {number} deltaY - The change in y-coordinate since the last drag event.
 * @property {number} lastX - The x-coordinate at the previous drag event.
 * @property {number} lastY - The y-coordinate at the previous drag event.
 */

import React, {
  forwardRef,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";
import Draggable from "react-draggable";
import { twClassNames } from "@/packages/utils/tailwindUtils";
import PropTypes from "prop-types";

import { KEYBOARD_KEYS } from "../../shared/keyEnums";

/**
 * Calculates the bounded position based on new coordinates and boundary constraints.
 * @param {number} newX - The proposed new x-coordinate.
 * @param {number} newY - The proposed new y-coordinate.
 * @param {DraggableWrapperProps['bounds']} bounds - The boundary definition.
 * @returns {{x: number, y: number}} The calculated position constrained by the bounds.
 */
const calculateBoundedPosition = (newX, newY, bounds) => {
  if (bounds && typeof bounds === "object") {
    return {
      x: Math.max(bounds.left || 0, Math.min(newX, bounds.right || newX)),
      y: Math.max(bounds.top || 0, Math.min(newY, bounds.bottom || newY)),
    };
  }
  return { x: newX, y: newY };
};

/**
 * Custom hook to manage keyboard dragging state and logic.
 * @param {object} options - Hook configuration.
 * @param {{x: number, y: number}} options.controlledPosition - The current position state of the draggable element.
 * @param {React.Dispatch<React.SetStateAction<{x: number, y: number}>>} options.setControlledPosition - State setter function for the position.
 * @param {DraggableWrapperProps['bounds']} options.bounds - The boundary definition used for keyboard movement calculation.
 * @returns {{isKeyboardDragging: boolean, setIsKeyboardDragging: React.Dispatch<React.SetStateAction<boolean>>}} An object containing the keyboard dragging state and its setter.
 */
const useKeyboardDrag = ({
  controlledPosition,
  setControlledPosition,
  bounds,
}) => {
  const [isKeyboardDragging, setIsKeyboardDragging] = useState(false);
  const keyboardDragIntervalRef = useRef(null);

  const handleKeyboardDrag = useCallback(
    key => {
      const moveStep = 10;
      const keyMappings = {
        [KEYBOARD_KEYS.ARROW_LEFT]: { x: -moveStep, y: 0 },
        [KEYBOARD_KEYS.ARROW_RIGHT]: { x: moveStep, y: 0 },
        [KEYBOARD_KEYS.ARROW_UP]: { x: 0, y: -moveStep },
        [KEYBOARD_KEYS.ARROW_DOWN]: { x: 0, y: moveStep },
      };

      if (keyMappings[key]) {
        const newX = controlledPosition.x + keyMappings[key].x;
        const newY = controlledPosition.y + keyMappings[key].y;
        const boundedPosition = calculateBoundedPosition(newX, newY, bounds);
        setControlledPosition(boundedPosition);
      }
    },
    [controlledPosition, setControlledPosition, bounds]
  );

  const startContinuousDrag = useCallback(
    key => {
      if (keyboardDragIntervalRef.current) {
        clearInterval(keyboardDragIntervalRef.current);
      }

      handleKeyboardDrag(key);
      keyboardDragIntervalRef.current = setInterval(() => {
        handleKeyboardDrag(key);
      }, 50);
    },
    [handleKeyboardDrag]
  );

  const stopContinuousDrag = useCallback(() => {
    if (keyboardDragIntervalRef.current) {
      clearInterval(keyboardDragIntervalRef.current);
      keyboardDragIntervalRef.current = null;
    }
  }, []);

  useEffect(() => {
    const handleKeyDown = e => {
      if (e.key === KEYBOARD_KEYS.SPACE && !isKeyboardDragging) {
        e.preventDefault();
        setIsKeyboardDragging(true);
      } else if (e.key === "Tab" && isKeyboardDragging) {
        setIsKeyboardDragging(false);
        stopContinuousDrag();
        return;
      }

      if (isKeyboardDragging) {
        const dragKeys = [
          KEYBOARD_KEYS.ARROW_LEFT,
          KEYBOARD_KEYS.ARROW_RIGHT,
          KEYBOARD_KEYS.ARROW_UP,
          KEYBOARD_KEYS.ARROW_DOWN,
        ];
        if (dragKeys.includes(e.key)) {
          e.preventDefault();
          startContinuousDrag(e.key);
        }
      }
    };

    const handleKeyUp = e => {
      const dragKeys = [
        KEYBOARD_KEYS.ARROW_LEFT,
        KEYBOARD_KEYS.ARROW_RIGHT,
        KEYBOARD_KEYS.ARROW_UP,
        KEYBOARD_KEYS.ARROW_DOWN,
      ];
      if (isKeyboardDragging && dragKeys.includes(e.key)) {
        stopContinuousDrag();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      stopContinuousDrag();
    };
  }, [isKeyboardDragging, startContinuousDrag, stopContinuousDrag]);

  return { isKeyboardDragging, setIsKeyboardDragging };
};

/**
 * A wrapper component that makes its children draggable via mouse/touch and keyboard.
 * It enhances the `react-draggable` library with accessibility features and keyboard navigation.
 *
 * @component
 * @param {DraggableWrapperProps} props - The properties for the DraggableWrapper component.
 * @param {React.Ref<HTMLDivElement>} ref - Forwarded ref to the underlying draggable DOM element.
 * @returns {React.ReactElement} The rendered DraggableWrapper component.
 * @type {React.ForwardRefExoticComponent<DraggableWrapperProps & React.RefAttributes<HTMLDivElement>>}
 */
const DraggableWrapper = forwardRef(
  (
    {
      bounds = "",
      children = null,
      containerClassName = "",
      disabled = false,
      handle = null,
      initialPosition = { x: 0, y: 0 },
      isBodyBounded = false,
      keyboardInstructions = "",
      onDrag = null,
      onStart = null,
      onStop = null,
      position = null,
      wrapperClassName = "",
    },
    nodeRef
  ) => {
    const [controlledPosition, setControlledPosition] = useState(
      position || initialPosition || { x: 0, y: 0 }
    );
    const dragContainerRef = useRef(null);

    useEffect(() => {
      if (position) {
        setControlledPosition(position);
      }
    }, [position]);

    const { isKeyboardDragging, setIsKeyboardDragging } = useKeyboardDrag({
      controlledPosition,
      setControlledPosition,
      bounds,
    });

    const onDragStart = (e, data) => {
      onStart?.(e, data);
    };

    const onDragStop = (e, data) => {
      setControlledPosition({ x: data.x, y: data.y });
      setIsKeyboardDragging(false);
      onStop?.(e, data);
    };

    const onDragHandler = (e, data) => {
      setControlledPosition({ x: data.x, y: data.y });
      onDrag?.(e, data);
    };

    return (
      <div
        ref={dragContainerRef}
        role="application"
        aria-label="Draggable element"
        aria-describedby="draggable-instructions"
        className={twClassNames(containerClassName)}
      >
        <Draggable
          onStart={onDragStart}
          onStop={onDragStop}
          onDrag={onDragHandler}
          bounds={isBodyBounded ? "body" : bounds}
          handle={handle}
          disabled={disabled || isKeyboardDragging}
          position={controlledPosition}
          nodeRef={nodeRef}
          defaultClassName={twClassNames("sticky z-200", wrapperClassName)}
        >
          <div
            tabIndex={0}
            role="button"
            aria-grabbed={isKeyboardDragging}
            aria-live="polite"
            aria-describedby="draggable-keyboard-instructions"
          >
            {children}
          </div>
        </Draggable>
        <div
          id="draggable-keyboard-instructions"
          className="sr-only"
          aria-live="polite"
        >
          {isKeyboardDragging
            ? "You are currently dragging the item. Use arrow keys to move. Press Tab or Space to release."
            : keyboardInstructions ||
              "Press Space to enter keyboard dragging mode."}
        </div>
      </div>
    );
  }
);

DraggableWrapper.propTypes = {
  /**
   * Specifies movement boundaries.
   * - `'parent'`: Restricts movement within the node's offsetParent.
   * - `string`: A CSS selector for the boundary element.
   * - `object`: `{left?: number, top?: number, right?: number, bottom?: number}` defining pixel offsets.
   */
  bounds: PropTypes.oneOfType([
    PropTypes.oneOf(["parent"]),
    PropTypes.string,
    PropTypes.shape({
      bottom: PropTypes.number,
      left: PropTypes.number,
      right: PropTypes.number,
      top: PropTypes.number,
    }),
  ]),
  /** Node containing the content that will be displayed within the Draggable component. */
  children: PropTypes.node,
  /** A custom CSS class name to style the outer container of the Draggable component. */
  containerClassName: PropTypes.string,
  /** If true, will not call any drag handlers and disable interaction. */
  disabled: PropTypes.bool,
  /** Specifies a CSS selector for the element to be used as the drag handle. */
  handle: PropTypes.string,
  /**
   * Initial position `{x: number, y: number}`. Used only on mount if `position` is not provided.
   * @property {number} x - Initial horizontal offset.
   * @property {number} y - Initial vertical offset.
   */
  initialPosition: PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number,
  }),
  /** If true, bounds the draggable area to the `<body>` element, overriding the `bounds` prop. */
  isBodyBounded: PropTypes.bool,
  /** Custom instructions for screen readers regarding keyboard navigation. */
  keyboardInstructions: PropTypes.string,
  /**
   * Callback function invoked continuously during drag.
   * `(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false`
   */
  onDrag: PropTypes.func,
  /**
   * Callback function invoked when dragging starts. Returning `false` cancels the drag.
   * `(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false`
   */
  onStart: PropTypes.func,
  /**
   * Callback function invoked when dragging stops.
   * `(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false`
   */
  onStop: PropTypes.func,
  /**
   * Controlled position `{x: number, y: number}`. Makes the component controlled.
   * @property {number} x - Controlled horizontal offset.
   * @property {number} y - Controlled vertical offset.
   */
  position: PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number,
  }),
  /** A custom CSS class name to style the inner draggable element managed by `react-draggable`. */
  wrapperClassName: PropTypes.string,
};

DraggableWrapper.displayName = "Draggable";

/**
 * @component DraggableWrapper
 * @storybook https://master--63a3f85277e81b426be0fdf8.chromatic.com/?path=/story/application-components-draggable--primary
 * @zeroHeight
 *
 * @description
 * An accessible wrapper component that enables mouse, touch, and keyboard dragging for its children.
 * It builds upon `react-draggable` by adding robust keyboard navigation (Space to activate, Arrows to move, Tab/Space to release)
 * and ARIA attributes for enhanced screen reader support. Includes boundary checking for controlled movement.
 *
 * @example
 * // Basic usage - Draggable anywhere
 * <DraggableWrapper>
 *   <div style={{ padding: '10px', border: '1px solid black', background: 'white' }}>Drag Me</div>
 * </DraggableWrapper>
 *
 * // With keyboard navigation, initial position, and parent bounds
 * <div style={{ height: '300px', width: '500px', border: '1px dashed grey', position: 'relative' }}>
 *   <DraggableWrapper
 *     bounds="parent"
 *     initialPosition={{ x: 50, y: 50 }}
 *     keyboardInstructions="Press Space to grab, use Arrows to move, Space/Tab to release."
 *   >
 *     <div style={{ padding: '10px', border: '1px solid blue', background: 'lightblue' }}>Drag Me (Keyboard OK)</div>
 *   </DraggableWrapper>
 * </div>
 *
 * // Controlled component
 * const [pos, setPos] = useState({ x: 10, y: 10 });
 * const handleDrag = (e, data) => setPos({ x: data.x, y: data.y });
 * <DraggableWrapper position={pos} onDrag={handleDrag}>
 *   <div>Controlled Drag</div>
 * </DraggableWrapper>
 *
 * @keyboard
 * - **Focus the draggable element:** Use Tab key.
 * - **Activate Keyboard Dragging:** Press Spacebar while focused. Screen reader announces activation.
 * - **Move Element:** Use Arrow Keys (Up, Down, Left, Right) while keyboard dragging is active.
 * - **Deactivate Keyboard Dragging:** Press Spacebar or Tab key. Screen reader announces deactivation.
 *
 * @accessibility
 * - **Role:** Outer container uses `role="application"`, inner focusable element uses `role="button"`.
 * - **State:** `aria-grabbed` indicates whether the element is currently being dragged via keyboard.
 * - **Instructions:** `aria-describedby` links the draggable element to dynamically updated instructions (visible only to screen readers) in a separate `div` with `aria-live="polite"`.
 * - **Focus Management:** The inner `div` is focusable (`tabIndex={0}`).
 *
 * @updates
 * - Integrated `useKeyboardDrag` hook for keyboard navigation logic.
 * - Added comprehensive ARIA attributes (`role`, `aria-label`, `aria-describedby`, `aria-grabbed`, `aria-live`).
 * - Implemented dynamic screen reader instructions based on dragging state.
 * - Refined boundary calculations (`calculateBoundedPosition`).
 * - Improved state management for controlled (`position`) and uncontrolled (`initialPosition`) modes.
 * - Enhanced event handling to coordinate mouse/touch and keyboard dragging.
 * - Added `isBodyBounded` prop for simple body boundary constraint.
 * - Forwarded ref (`nodeRef`) correctly to `react-draggable`.
 *
 * @props
 * @prop {('parent'|string|{left?: number, top?: number, right?: number, bottom?: number})} [bounds] - Defines movement boundaries.
 * @prop {React.ReactNode} [children] - Content to make draggable.
 * @prop {string} [containerClassName] - CSS classes for the outer container.
 * @prop {boolean} [disabled=false] - Disables all dragging.
 * @prop {string} [handle] - CSS selector for the drag handle element.
 * @prop {{x: number, y: number}} [initialPosition={x: 0, y: 0}] - Starting position (uncontrolled).
 * @prop {boolean} [isBodyBounded=false] - If true, bounds to `<body>`, overrides `bounds`.
 * @prop {string} [keyboardInstructions=''] - Custom screen reader text for keyboard mode activation.
 * @prop {(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false} [onDrag] - Callback during drag.
 * @prop {(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false} [onStart] - Callback on drag start. Return `false` to cancel.
 * @prop {(event: MouseEvent | TouchEvent | KeyboardEvent, data: DraggableData) => void | false} [onStop] - Callback on drag end.
 * @prop {{x: number, y: number}} [position] - Controlled position. Overrides `initialPosition`.
 * @prop {string} [wrapperClassName] - CSS classes for the inner `react-draggable` element.
 *
 * @internals
 * - Uses `react-draggable` library for core mouse/touch drag functionality.
 * - Employs `useState` for managing internal position state (`controlledPosition`).
 * - Uses `useEffect` to sync with the controlled `position` prop.
 * - Leverages `useRef` for DOM node references (`dragContainerRef`, `nodeRef`).
 * - Custom hook `useKeyboardDrag` encapsulates keyboard interaction logic (state, event listeners, interval for continuous movement).
 * - Helper function `calculateBoundedPosition` enforces boundary constraints.
 * - Uses `twClassNames` utility for merging CSS classes.
 *
 * @end
 */

export default DraggableWrapper;
